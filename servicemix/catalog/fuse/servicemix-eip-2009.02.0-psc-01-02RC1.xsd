<?xml version='1.0'?>
<!-- NOTE: this file is autogenerated by Apache XBean -->

<xs:schema elementFormDefault='qualified'
           targetNamespace='http://servicemix.apache.org/eip/1.0'
           xmlns:xs='http://www.w3.org/2001/XMLSchema'
           xmlns:tns='http://servicemix.apache.org/eip/1.0'>

  <!-- element for type: org.apache.servicemix.eip.patterns.AsyncBridge -->
  <xs:element name='async-bridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The async bridge pattern is used to bridge an In-Out exchange with two In-Only
(or Robust-In-Only) exchanges. This pattern is the opposite of the {@link Pipeline}.
<br/>
The AsyncBridge uses a correlation identifier to be able to correlate the received
In-Out exchange, the In-Only sent as the request and the In-Only received as the response.
Defaults values are provided to configure those correlation ids. The default behavior
is to use the exchange id of the incoming In-Out exchange as the correlation id and set
it on the request exchange. The same property with the same value should be present on the
response exchange in order for the AsyncBridge to work. ServiceMix components usually take
care of propagating such properties, but failing to propagate it will result in errors.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The target which will be used to send an In-Only or Robust-In-Only exchange to.
When receiving an In-Out exchange, the async bridge will create an In-Only request
and send it to the specified target. It then expects another In-Only exchange to
come back as the response, which will be set as the Out message on the In-Out exchange.
This property is mandatory and must be set to a valid target.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='requestCorrId' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The expression used to compute the correlation id used to correlate the response and
the request. The default behavior is to use the exchange id of the incoming In-Out
exchange as the correlation id.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='responseCorrId' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The expression used to compute the correlation id from the response exchange.
The value computed by this expression must match the one from the {@link #setRequestCorrId}
expression. The default value is null, but if no specific expression is configured,
an expression will be created which will extract the response correlation id from the
{@link #setResponseCorrIdProperty(String)} property on the exchange.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='responseCorrIdProperty' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Name of the property used by default to compute the correlation id on the response
exchange.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The target which will be used to send an In-Only or Robust-In-Only exchange to.
When receiving an In-Out exchange, the async bridge will create an In-Only request
and send it to the specified target. It then expects another In-Only exchange to
come back as the response, which will be set as the Out message on the In-Out exchange.
This property is mandatory and must be set to a valid target.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timeout property controls the amount of time that the async bridge will wait for the response
after having sent the request. The default value is 0 which means that no timeout apply. If set
to a non zero value, a timer will be started when after the request is sent. When the timer
expires, the In-Out exchange will be sent back with an error status and a
{@link java.util.concurrent.TimeoutException} as the cause of the error.
The value represents the number of milliseconds to wait.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useRobustInOnly' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag to control if In-Only or Robust-In-Only exchange should be used
when sending the request. The default value is <code>false</code> which means
that an In-Only exchange will be used. When using a Robust-In-Only exchange and
when a fault is received, this fault will be sent back to the consumer on the In-Out
exchange and the response exchange (if any) would be discarded.
For both In-Only and Robust-In-Only, if the request exchange comes back with an Error
status, this error will be conveyed back to the consumer in the same way.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.EIPComponent -->
  <xs:element name='component'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An EIP component
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='endpoints' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A list of endpoints to activate on this component.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:async-bridge'/>
              <xs:element ref='tns:content-based-router'/>
              <xs:element ref='tns:content-enricher'/>
              <xs:element ref='tns:message-filter'/>
              <xs:element ref='tns:pipeline'/>
              <xs:element ref='tns:recipient-list-aggregator'/>
              <xs:element ref='tns:resequencer'/>
              <xs:element ref='tns:split-aggregator'/>
              <xs:element ref='tns:static-recipient-list'/>
              <xs:element ref='tns:static-routing-slip'/>
              <xs:element ref='tns:wire-tap'/>
              <xs:element ref='tns:xpath-splitter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The executor to use for various tasks that need to be performed by the component.
If none is provided, one will be created from the executorFactory.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='executorFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The executor factory to use to create the executor.
If none is provided, one will be retrieved from the JBI container when the component
is deployed into ServiceMix 3.x, or a default implementation will be used.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='executor' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The executor to use for various tasks that need to be performed by the component.
If none is provided, one will be created from the executorFactory.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='executorFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The executor factory to use to create the executor.
If none is provided, one will be retrieved from the JBI container when the component
is deployed into ServiceMix 3.x, or a default implementation will be used.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.ContentBasedRouter -->
  <xs:element name='content-based-router'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        ContentBasedRouter can be used for all kind of content-based routing.
This component implements the
<a href="http://www.enterpriseintegrationpatterns.com/ContentBasedRouter.html">Content-Based Router</a>
pattern.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='rules' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The list of routing rules.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:routing-rule'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forwardOperation' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Forward the operation qname when sending the exchange to the target.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.ContentEnricher -->
  <xs:element name='content-enricher'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implementation of the
<a href="http://www.enterpriseintegrationpatterns.com/DataEnricher.html">Content-Enricher</a>
Pattern.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='enricherTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The target that will receive a copy of the input message and return
an addtitional content.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The target where the enriched exchanges are sent.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='copyAttachments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this is set to <code>true</code>, message attachments from the incoming exchange and the enricher exchange will be copied
to the outgoing message exchange. The default value is <code>false</code> (do not copy message atachments).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this is set to <code>true</code>, message properties from the incoming exchange and the enricher exchange will be copied
to the outgoing message exchange. The default value is <code>false</code> (do not copy message properties).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='enricherElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            returns the QName of the resulting root node
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='enricherTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The target that will receive a copy of the input message and return
an addtitional content.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='requestElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the QName of the element which contains the 'IN Message'
within the response message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='resultElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the QName of the element which contains the message
which was produced by the enricherTarget within the
response message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The target where the enriched exchanges are sent.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.resequence.DefaultComparator -->
  <xs:element name='default-comparator'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Compares {@link MessageExchange} sequence elements based on sequence numbers
defined by their in-{@link javax.jbi.messaging.NormalizedMessage}s. This comparator works on
sequence numbers of type {@link Long}. Sequence numbers must be stored as
{@link javax.jbi.messaging.NormalizedMessage} properties. The property name under which the
sequence number is stored is configured via this comparator's
<code>sequenceNumberKey</code> property.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='sequenceNumberKey' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The property name on the input message containing the sequence number
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.ExchangeTarget -->
  <xs:element name='exchange-target'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ExchangeTarget may be used to specify the target of an exchange,
while retaining all the JBI features (interface based routing, service
name based routing or endpoint routing).
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The endpoint name of the target.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interface' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The interface QName implemented by the target
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='operation' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The operation QName that will be set on the exchange
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The service QName of the target
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='uri' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An URI identifying the target
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.MessageFilter -->
  <xs:element name='message-filter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        MessageFilter allows filtering incoming JBI exchanges.
This component implements the
<a href="http://www.enterpriseintegrationpatterns.com/Filter.html">Message Filter</a>
pattern.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='filter' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The filter to use on incoming messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:switch-predicate'/>
              <xs:element ref='tns:xpath-predicate'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The main target destination which will receive the exchange
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='filter' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The filter to use on incoming messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates if faults and errors from recipients should be sent
back to the consumer. In such a case, only the first fault or
error received will be reported.
Note that if the consumer is synchronous, it will be blocked
until all recipients successfully acked the exchange, or
a fault or error is reported, and the exchange will be kept in the
store for recovery.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The main target destination which will receive the exchange
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.NamespaceContextImpl -->
  <xs:element name='namespace-context'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A simple namespace context.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='namespaces' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Keep the getter/setter to keep xbean annotation
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='namespaces' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Keep the getter/setter to keep xbean annotation
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.Pipeline -->
  <xs:element name='pipeline'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The Pipeline component is a bridge between an In-Only (or Robust-In-Only) MEP and
an In-Out MEP.
When the Pipeline receives an In-Only MEP, it will send the input in an In-Out MEP
to the tranformer destination and forward the response in an In-Only MEP to the target
destination.
In addition, this component is fully asynchronous and uses an exchange store to provide
full HA and recovery for clustered / persistent flows.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='faultsTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The address of the endpoint to send faults to
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The address of the target endpoint
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The adress of the in-out endpoint acting as a transformer
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='copyAttachments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should message attachments be copied ?
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should message properties be copied ?
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='faultsTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The address of the endpoint to send faults to
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sendFaultsToTarget' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When the faultsTarget is not specified,
faults may be sent to the target endpoint
if this flag is set to <code>true</code>
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The address of the target endpoint
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transformer' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The adress of the in-out endpoint acting as a transformer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.RecipientListAggregator -->
  <xs:element name='recipient-list-aggregator'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An aggregator specifically written to aggregate messages that have been sent using
a StaticRecipientList pattern.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='closedAggregatesStoreFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Access the currently configured {@link StoreFactory} for storing closed aggregations
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The exchange target that will be used to send the aggregate to.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='aggregateElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name that will be used as the root xml element when building the aggregate.
Messages contents will be appended to this root element as direct children or inside
an element dependending on the <code>messageElementName</code> property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='closedAggregatesStoreFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Access the currently configured {@link StoreFactory} for storing closed aggregations
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyAttachments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Copy all attachments from the incoming messages to the aggregated
message. Default value is <code>true</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Copy all properties from the incoming messages to the aggregated
message. Default value is <code>true</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='corrId' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the correlation ids of incoming messages to find
related messages. The default value is to retrieve the same property as the
splitter.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='count' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the total number of message that the aggregate will contain.
The default value is to retrieve the same property as the splitter. This property is evaluated
on each incoming message and must always have the same value for all messages in the same aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='countAttribute' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the xml attribute attached to the root element that will contain the number of
messages in this aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='index' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the index of this message in the aggregate.
For a given message, the index must be unique within the aggregate and must
range between <code>0</code> and <code>count - 1</code> included.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='indexAttribute' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the xml attribute attached to the message element that will contain the index of
messages in this aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the xml element used to embed each message
when building the aggregated message. If <code>null</code>, messages
contents will be appended directly as children of the root element.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportClosedAggregatesAsErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should report errors on incoming exchanges received after a given
aggregate has been closed.
The default value is <code>false</code>, meaning that such exchanges will be silently sent back
with a DONE status and discarded with respect to the aggregation process.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should report errors happening when sending the
aggregate on all exchanges that compose the aggregate.
The default value is <code>false</code>, meaning that if any error occur, this
error will be lost.
Note that if this flag is set to <code>true</code>, all exchanges received as part of a given aggregate
will be hold until the aggregate is sent and the DONE / ERROR status is received back.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportTimeoutAsErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should reports errors on incoming exchanges already received when
a timeout occurs.
The default value is <code>false</code>, meaning that such exchanges will be silently sent back
a DONE status.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rescheduleTimeouts' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag controlling if aggregate timeouts are rescheduled each time a new message is added
to the aggregate. If <code>false</code>, the timeout will expire when the specified amount of
time elapsed after the first message is received for this aggregate. If <code>true</code>,
the timeout will expire when the specified amount of time elapsed after the last message is received.
The default value is <code>false</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='synchronous' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag that Controls whether the aggregate (when ready) will be sent synchronously or not.
On ServiceMix 3.x, this can have an effect upon the flow and transaction semantics.
The default value is <code>false</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The exchange target that will be used to send the aggregate to.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The maximum amount of time (in milliseconds) that can elapse between messages for a single aggregate.
The default value is <code>0</code> which means that the timeout is not used at all.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.Resequencer -->
  <xs:element name='resequencer'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This pattern implements the <a href="http://www.enterpriseintegrationpatterns.com/Resequencer.html">Resequencer</a> EIP
pattern. The aim of this pattern is to put back into correct order a flow of out-of-sequence messages.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='comparator' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The comparator used to determine the sequence order of elements.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:default-comparator'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='capacity' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The capacity of this resequencer. The capacity determines the maximum number of message
that will be kept in memory to put the messages back in sequence. This determine how far
two messages can be in the list of messages while still being put back in sequence.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='comparator' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The comparator used to determine the sequence order of elements.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'/>
      <xs:attribute name='timeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the timeout of this resequencer. This specifies the maximum number of milliseconds
that can elapse between two out-of-sync messages.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.RoutingRule -->
  <xs:element name='routing-rule'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The RoutingRule interface is used by content based routers.
If the rule predicate matches the MessageExchange, the
target defined on the rule will be used as the destination for
the given MessageExchange.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='predicate' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The predicate associated to this routing rule.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:switch-predicate'/>
              <xs:element ref='tns:xpath-predicate'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The target to send the routed exchange to if the predicate matches.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='predicate' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The predicate associated to this routing rule.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The target to send the routed exchange to if the predicate matches.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.SplitAggregator -->
  <xs:element name='split-aggregator'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Aggregator can be used to wait and combine several messages.
This component implements the
<a href="http://www.enterpriseintegrationpatterns.com/Aggregator.html">Aggregator</a>
pattern.

This aggregator collect messages with a count, index and correlationId properties.
These properties are automatically set by splitters.
A timeout may be specified so that the aggregator will not keep data forever if a message is missing.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='closedAggregatesStoreFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Access the currently configured {@link StoreFactory} for storing closed aggregations
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The exchange target that will be used to send the aggregate to.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='aggregateElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name that will be used as the root xml element when building the aggregate.
Messages contents will be appended to this root element as direct children or inside
an element dependending on the <code>messageElementName</code> property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='closedAggregatesStoreFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Access the currently configured {@link StoreFactory} for storing closed aggregations
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyAttachments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Copy all attachments from the incoming messages to the aggregated
message. Default value is <code>true</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Copy all properties from the incoming messages to the aggregated
message. Default value is <code>true</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='corrId' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the correlation ids of incoming messages to find
related messages. The default value is to retrieve the same property as the
splitter.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='count' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the total number of message that the aggregate will contain.
The default value is to retrieve the same property as the splitter. This property is evaluated
on each incoming message and must always have the same value for all messages in the same aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='countAttribute' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the xml attribute attached to the root element that will contain the number of
messages in this aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='index' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An expression used to compute the index of this message in the aggregate.
For a given message, the index must be unique within the aggregate and must
range between <code>0</code> and <code>count - 1</code> included.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='indexAttribute' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the xml attribute attached to the message element that will contain the index of
messages in this aggregate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageElementName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the xml element used to embed each message
when building the aggregated message. If <code>null</code>, messages
contents will be appended directly as children of the root element.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportClosedAggregatesAsErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should report errors on incoming exchanges received after a given
aggregate has been closed.
The default value is <code>false</code>, meaning that such exchanges will be silently sent back
with a DONE status and discarded with respect to the aggregation process.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should report errors happening when sending the
aggregate on all exchanges that compose the aggregate.
The default value is <code>false</code>, meaning that if any error occur, this
error will be lost.
Note that if this flag is set to <code>true</code>, all exchanges received as part of a given aggregate
will be hold until the aggregate is sent and the DONE / ERROR status is received back.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportTimeoutAsErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the aggregator should reports errors on incoming exchanges already received when
a timeout occurs.
The default value is <code>false</code>, meaning that such exchanges will be silently sent back
a DONE status.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rescheduleTimeouts' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag controlling if aggregate timeouts are rescheduled each time a new message is added
to the aggregate. If <code>false</code>, the timeout will expire when the specified amount of
time elapsed after the first message is received for this aggregate. If <code>true</code>,
the timeout will expire when the specified amount of time elapsed after the last message is received.
The default value is <code>false</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='synchronous' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag that Controls whether the aggregate (when ready) will be sent synchronously or not.
On ServiceMix 3.x, this can have an effect upon the flow and transaction semantics.
The default value is <code>false</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The exchange target that will be used to send the aggregate to.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The maximum amount of time (in milliseconds) that can elapse between messages for a single aggregate.
The default value is <code>0</code> which means that the timeout is not used at all.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.StaticRecipientList -->
  <xs:element name='static-recipient-list'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The StaticRecipientList component will forward an input In-Only or Robust-In-Only
exchange to a list of known recipients.
This component implements the
<a href="http://www.enterpriseintegrationpatterns.com/RecipientList.html">Recipient List</a>
pattern, with the limitation that the recipient list is static.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='recipients' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A list of recipients that will each receive a copy of the input message.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates if faults and errors from recipients should be sent
back to the consumer. In such a case, only the first fault or
error received will be reported.
Note that if the consumer is synchronous, it will be blocked
until all recipients successfully acked the exchange, or
a fault or error is reported, and the exchange will be kept in the
store for recovery.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.StaticRoutingSlip -->
  <xs:element name='static-routing-slip'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A RoutingSlip component can be used to route an incoming In-Out exchange
through a series of target services.
This endpoint implements the
<a href="http://www.enterpriseintegrationpatterns.com/RoutingTable.html">Routing Slip</a>
pattern, with the limitation that the routing table is static.
This endpoint only uses In-Out MEPs and errors or faults sent by targets are reported
back to the consumer, thus interrupting the routing process.
In addition, this endpoint is fully asynchronous and uses an exchange store to provide
full HA and recovery for clustered / persistent flows.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='targets' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              List of target endpoints used in the RoutingSlip
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.SwitchPredicate -->
  <xs:element name='switch-predicate'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Switch (on/off) predicate based on a property that can come from
a system property, a property from a property file (specified as Spring resource),
or a property from the exchange.
<p/>
The property is interpreted as a boolean value.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='fromExchange' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Boolean flag indicating that the value is retrieved from the exchange properties.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='on' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Default value of this predicate
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='propertyName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the property to retrieve
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='propertyResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A spring resource to load a set of properties from.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.WireTap -->
  <xs:element name='wire-tap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A WireTap component can be used to forward a copy of the input message to a listener.
This component implements the
<a href="http://www.enterpriseintegrationpatterns.com/WireTap.html">WireTap</a>
pattern.
It can handle all 4 standard MEPs, but will only send an In-Only MEP to the listener.
In addition, this component is fully asynchronous and uses an exchange store to provide
full HA and recovery for clustered / persistent flows.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='faultListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The listener destination for fault messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='inListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The listener destination for in messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='outListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The listener destination for out messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The main target destination which will receive the exchange
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='copyProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If copyProperties is <code>true</code>, properties
on the in message will be copied to the out / fault
message before it is sent.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='faultListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The listener destination for fault messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='inListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The listener destination for in messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='outListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The listener destination for out messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The main target destination which will receive the exchange
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.support.XPathPredicate -->
  <xs:element name='xpath-predicate'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A predicate that verify if the xpath expression evaluated on
the content of the input message is true or not.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='factory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The XPath factory. If no factory is explicitely configured, a defaut one will be created
using <code>XPathFactory.newInstance()</code>.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='functionResolver' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The function resolver.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='namespaceContext' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The namespace context to use when evaluating the xpath expression
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:namespace-context'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='variableResolver' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The variable resolver. The default one will enable the use of properties on the message, exchange,
as well as making system properties and environment properties available.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='XPath' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The xpath expression used to evaluate the predicate.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='factory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The XPath factory. If no factory is explicitely configured, a defaut one will be created
using <code>XPathFactory.newInstance()</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='functionResolver' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The function resolver.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='namespaceContext' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The namespace context to use when evaluating the xpath expression
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transformer' type='xs:string'/>
      <xs:attribute name='useMessageContent' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Ensure re-readability of the content if the expression also needs to
access the content.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='variableResolver' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The variable resolver. The default one will enable the use of properties on the message, exchange,
as well as making system properties and environment properties available.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='xpath' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.servicemix.eip.patterns.XPathSplitter -->
  <xs:element name='xpath-splitter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The XPathSplitter component implements the
<a href="http://www.enterpriseintegrationpatterns.com/Sequencer.html">Splitter</a>
pattern using an xpath expression to split the incoming xml.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='factory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The XPath factory. If no factory is explicitely configured, a defaut one will be created
using <code>XPathFactory.newInstance()</code>.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='functionResolver' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The function resolver.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='namespaceContext' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The namespace context to use when evaluating the xpath expression
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:namespace-context'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='target' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The address of the target endpoint.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='timerManager' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='variableResolver' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The variable resolver. The default one will enable the use of properties on the message, exchange,
as well as making system properties and environment properties available.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any namespace='##other'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wsdlExchangeTarget' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:exchange-target'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='endpoint' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The name of the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='factory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The XPath factory. If no factory is explicitely configured, a defaut one will be created
using <code>XPathFactory.newInstance()</code>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forwardAttachments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates if incoming attachments should be forwarded with the new exchanges.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forwardProperties' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates if properties on the incoming message should be forwarded.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='functionResolver' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The function resolver.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interfaceName' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the interface exposed by the endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The lock manager to use for this endpoint. If none is explicitely specified
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='namespaceContext' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The namespace context to use when evaluating the xpath expression
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reportErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates if faults and errors from splitted parts should be sent
back to the consumer. In such a case, only the first fault or
error received will be reported.
Note that if the consumer is synchronous, it will be blocked
until all parts have been successfully acked, or
a fault or error is reported, and the exchange will be kept in the
store for recovery.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='service' type='xs:QName'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The qualified name of the service the endpoint exposes.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='store' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Configure the store to use. If none is explicitely configured,
the storeFactory will be used to create one.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='storeFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The store factory to use when creating a store. If no factory
is explicitely defined, an in-memory only factory will be created.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='synchronous' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Specifies wether exchanges for all parts are sent synchronously or not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='target' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The address of the target endpoint.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timerManager' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The timer manager to use for this endpoint. If none is explicitely configured,
a default implementation will be provided.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='variableResolver' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The variable resolver. The default one will enable the use of properties on the message, exchange,
as well as making system properties and environment properties available.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlExchangeTarget' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            An exchange target pointing to a JBI endpoint that
will be used to load the WSDL describing this endpoint.
This can be used when the endpoint proxies another endpoint
so that the same WSDL definition will be exposed."
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wsdlResource' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When specified, this spring resource will be used to load the
WSDL that will be exposed as a description for this endpoint.
This property can be used to explicitely define the WSDL to be
exposed by this endpoint. This property takes precedence over
the wsdlExchangeTarget property.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='xpath' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The xpath expression used to split the input message.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


</xs:schema>
